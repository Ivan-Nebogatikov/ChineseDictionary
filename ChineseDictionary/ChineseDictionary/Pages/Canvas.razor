@page "/canvas"

@using HandwritingLibrary;
@using System;
@using System.Collections.Generic;
@using Newtonsoft.Json.Linq;

@inject IJSRuntime JsRuntime
@inject Toolbelt.Blazor.I18nText.I18nText I18nText
@inject HttpClient Http

<div>
    @if (characters != null)
    {
        @foreach (char ch in characters)
        {
            string hier = ch.ToString();
            <button style="width:46px;height:46px;margin-bottom:10px" class="btn btn-warning" name="filled">@hier</button>
        }
    }
    else
    {
        @for (var i = 0; i < 11; ++i)
        {
            <button style="width:42px;height:42px;margin-bottom:10px" class="btn btn-warning" name="empty"></button>
        }
    }
</div>
<div>
    <canvas id="canvas"
            height="@windowSize.Height"
            width="@windowSize.Width"
            style="border: 2px solid "
            @onmousedown="@StartPaintMouse"
            @onmousemove="@PaintMouse"
            @onmouseup="@StopPaint"
            @onmouseout="@StopPaint"
            @ref="@canvas"
            @ontouchstart="@StartPaintTouch"
            @ontouchmove="@PaintTouch"
            @ontouchend="@StopPaint" />
</div>
<div class="text-left">
    <button type="button" class="btn btn-danger btn-xs d-block mx-auto"
            @onclick="ClearCanvas">
        @localization.Clear
    </button>
</div>

@code {
    List<Stroke> strokes = new List<Stroke>();
    WindowSize windowSize = new WindowSize();
    ElementReference canvas;
    Canvas2DContext ctx;
    static JObject dictionary;
    char[] characters;
    bool isPainting = false;
    double x;
    double y;
    private Strings localization = new Strings();

    protected override async Task OnInitializedAsync()
    {
        localization = await I18nText.GetTextTableAsync<Strings>(this);
        windowSize = await JsRuntime.InvokeAsync<WindowSize>("getWindowSize");
        int SIZE = 500;
        if (windowSize.Width > 500)
        {
            windowSize.Height = SIZE;
            windowSize.Width = SIZE;
        }
        else
        {
            windowSize.Width = (int)(windowSize.Width * 0.9);
            windowSize.Height = windowSize.Width;
        }
        if (dictionary == null)
        {
            dictionary = JObject.Parse(await Http.GetStringAsync("orig.json"));
            dictionary["substrokes"] = CompactDecoder.Decode(dictionary["substrokes"].ToString());
        }
    }

    private void StartPaintMouse(MouseEventArgs e)
    {
        StartPainting(e.ClientX, e.ClientY);
    }

    private async Task PaintMouse(MouseEventArgs e)
    {
        await Paint(e.ClientX, e.ClientY);
    }

    private void StartPaintTouch(TouchEventArgs e)
    {
        StartPainting(e.Touches.First().ClientX, e.Touches.First().ClientY);
    }

    private async Task Paint(double pointX, double pointY)
    {
        if (isPainting)
        {
            var eX = pointX;
            var eY = pointY;
            if (ctx == null)
            {
                ctx = new Canvas2DContext(JsRuntime, canvas);
            }
            await ctx.DrawLine(x, y, eX, eY);
            x = eX;
            y = eY;
            strokes.Last().Points.Add(new Point { X = x, Y = y });
        }
    }

    private void StartPainting(double pointX, double pointY)
    {
        x = pointX;
        y = pointY;
        if (ctx == null)
        {
            ctx = new Canvas2DContext(JsRuntime, canvas);
        }
        isPainting = true;
        strokes.Add(new Stroke());
    }

    private async Task PaintTouch(TouchEventArgs e)
    {
        await Paint(e.Touches.First().ClientX, e.Touches.First().ClientY);
    }

    private void StopPaint()
    {
        if (isPainting)
        {
            var analyzer = new Analyzer(strokes);
            var subStrokes = analyzer.AnalyzedStrokes;
            var strokesCount = strokes.Count;
            var subStrokesCount = subStrokes.Count;
            int limit = 10;

            Console.WriteLine("Number of the input character's strokes: " + strokesCount);
            Console.WriteLine("Number of the input character's substrokes: " + subStrokesCount);

            Matcher mt = new Matcher(strokesCount, subStrokesCount, subStrokes, limit);
            characters = mt.DoMatching(dictionary);
        }
        isPainting = false;
    }

    public async Task ClearCanvas()
    {
        await JsRuntime.InvokeAsync<object>("__blazorCanvasInterop.clearCanvas", canvas);
    }
}
